%% gofFluence
% Compute the goodness of fit function between a target fluence map |FluenceRef|
% and the fluence map generated by a spike of a CEF:
%  gof = A .* Fluence([r1,r2,...,rn]) - FluenceRef
%
%% Syntax
% |gof = gofFluence(x , Plan , b , k , sigma0 , Meas_Zg , sigmas_far , FluenceRef)|
%
%
%% Description
% |gof = gofFluence(x , Plan , b , k , sigma0 , Meas_Zg , sigmas_far , FluenceRef)| Description
%
%
%% Input arguments
% |x| -_SCALAR VECTOR_- The optimised parameters |x = [A , dr1 , dr2, ... , drn]| where the relative width of the lowers step is dr1 and the relative width of the highest step is drn
%
% |Plan| - _struct_ - MIROpt structure with updated information. See fluenceWithCEF.m for more information
%     * |Plan.Spike.intrpCTpxlSize| -_SCALAR_- Lateral resolution (mm) of the 3D printer. The steps are multiple of this value.
%
% |b| -_INTEGER_- Index of the beam in |Plan.Beams(b)| for which the fluence map is to be computed
%
% |SpikeIdx| -_INTEGER_- Index of the spike in |Plan.Beams(b).RidgeFilter(SpikeIdx)| that should be optimizes
%
% |Meas_Zg| -_SCALAR_- Z coordinate in IEC-Gantry (mm) of the plane in which the fluence is measured
%
% |showGraph| -_LOGICAL_- [Optional: defauly = false] If true, display the graphs ofthe fluence at different steps i nthe computations
%
% |sigmas_far| -_SCALAR VECTOR_- [OTPIONAL: if [], the sigma are computed by the function]. sigma (mm) of the lateral spread of the beam at |distance| of the scatterer
%
% |FluenceRef(x,y,E)| -_SCALAR MATRIX_-  Reference fluence at |distance| downstream from the CEF that the gof tries to reproduce. |Fluence(x,y,E)|  fluence at position (x,y) for proton of energy |Plan.Beams(b).Layers(E).Energy|
%
% |apertureMask| -_SCALAR MATRIX_- |apertureMask(x,y)=1| if the pixel is inside the aperture opening. The GOF is based only on the fluence inside the aperture opening. Empty if no aperture is used
%
% |WaterThickeness| -_SCALAR_- Thickness (mm) of the water tank placed at the position of hte measurement plane
%
% |conv_coor| -_SCALAR MATRIX_- [OPTIONAL: used to make computation faster. If absent, the parameter is computed] |conv_coor(m,n)=i| the point |[x_grid(m),y_grid(n)]| of the cartesian coordinate system has polar coordinates |R(i)| and |Phi(i)| in polar coordinates
%
%% Output arguments
%
% |gof| - _SCALAR_ -  Goodness of fit. Sum of the square differences
%
% |FluenceOpt|  -_SCALAR MATRIX_-  Fluence of the optimised spike at |distance| downstream from the CEF that the gof tries to reproduce. |Fluence(x,y,E)|  fluence at position (x,y) for proton of energy |Plan.Beams(b).Layers(E).Energy|
%
%
%% Contributors
% Authors : R. Labarbe (open.reggui@gmail.com)

function [gof , FluenceOpt] = gofSOBP(x , Plan , b , SpikeIdx , sigma0 , Meas_Zg , sigmas_far , FluenceRef, apertureMask , WaterThickeness , E_ref)

    sFluenceRef = size(FluenceRef);

    if isempty(apertureMask)
      %If the aperture mask is empty, then use all fluence pixels in the computation of GOF
      apertureMask = ones(sFluenceRef);
    else
      %An aperture mask is provided. Repeat for eack energy layer
      apertureMask = repmat(apertureMask,1,sFluenceRef(3)); %repeat for every energy layer
      apertureMask = reshape(apertureMask,sFluenceRef);
    end

    pencil_x = [Plan.Beams(b).RidgeFilter(:).x_centre]; %Position of the centre of the spikes is also the centre of the PBS spots
    pencil_y = [Plan.Beams(b).RidgeFilter(:).y_centre];
    weight_table = [Plan.Beams(b).RidgeFilter(:).w]; % w(spt) is the weight of the spt-th PBS spot. The value is proportional to the number of proton at **maximum** energy

    E_spike = Plan.Beams(b).RidgeFilter(SpikeIdx).Energy; %The energy corresponding to spot weights |w0_step|
    W0 = Plan.Beams(b).RidgeFilter(SpikeIdx).w0_step; % w_step(l) weight of the l-th energy layer to the spot |SpikeIdx|. Proportional to number of protons of **maximum** energy
    W0 = W0 ./ sum(W0); %Normalise the reference weights of the IMPT plan

    %Plan.Beams(b).RidgeFilter  = packRgofFluence(x,Plan.Beams(b).RidgeFilter(SpikeIdx), Plan.Spike.LateralStep); %Update the width of the steps using the X variable
    [Plan.Beams(b).RidgeFilter , Xout] = packRgofFluence(x,Plan.Beams(b).RidgeFilter(SpikeIdx), 0); %Update the width of the steps using the X variable
    %Plan contains the definition of one single spike after the call to packRgofFluence

    %Define the level of graphical display
    if Plan.showGraph
      showGraph = 2;
    else
      showGraph = 0;
    end

    %Compute the fluence map (for the single spike)
    [FluenceSpk , X_far , Y_far , ~ , ~ , ~ , maskLayer] = fluenceWithCEF(Plan , b , sigma0 , pencil_x , pencil_y , weight_table, [] , Meas_Zg , showGraph , sigmas_far, WaterThickeness, 'config_CEM_RS');

    %Make the computation only in the area of the spike
    mask = ~~sum(maskLayer,3);


    %compute the reference weights from the reference fluence map
    Fluence = zeros(numel(X_far),numel(Y_far), numel(E_ref));
    W0ext = zeros(numel(E_ref),1); %There are missing energy layers in the W0 reference

    for ind_E = 1:numel(E_spike)
        %If there are missing energy layers in this spike, sort energy layers to match reference
        idx = find(E_ref == E_spike(ind_E)); %Find the index of the energy layer corrsponding to cylinder j
        Fluence    (: , : , idx) = FluenceSpk(:,:,ind_E);
        W0ext(idx) = W0(ind_E); %Create a reference weight vector with all energy layers
    end

    %Normalise the weight and compare the IDD
    W0ext = W0ext ./ sum(W0ext); %Normalise the weight
    W = squeeze(sum(Fluence .* mask,[1,2])); %Compute the weight of each energy layer
    W = W ./ sum(W); %Normalise the weight
    [IDD , Z] = W2dose(W  , E_ref ); %Integrated depth dose profile through CEF
    IDDRef    = W2dose(W0ext  , E_ref ); %Integrated depth dose profile of the IMPT plan

    if Plan.showGraph
      figure(151)
      hold off
      plot(Z , IDDRef , '-b')
      hold on
      plot(Z , IDD , '-r')
      xlabel('Depth (mm)')
      ylabel('Relative dose')
      title('GOF : Integrated depth dose')
      grid on

      figure(150)
      title(['Spike nb ' num2str(SpikeIdx)])

    end

    gof = sum((IDD - IDDRef).^2);

    %If the vector x was outside of the constraints, then the value of GOF must be increased, in proportion to the deviation to the constraints
    %in order to bring the optimiser into the authorised range of x
    deviation = max(abs((x - Xout) ./ Xout)); %Maximum deviation outside the constrainted zone
    if deviation
      %If the x was outside of the constrained area, add a penalty to the gof value
      %Multiply the gof by the penalty factor in order to get a smooth function between inside and outside the constrainted area
      gof = gof .* exp(deviation);
    end


end

%=======================================================
%Convert the fluence into dose
function [DoseDepth , Z] = W2dose(W  , E_ref )

    water = materialDescription('water');
    R = energy2range(E_ref, water.alpha,water.p); %Range (cm) of incoming particle

    %Convert fluence into dose using the Bortfeld depth dose profile
    Z = min(R):0.1:max(R);
    intDose = zeros(numel(E_ref), numel(Z));

    beam.epsilon = 0.2; % _SCALAR_ -  fraction of low energy proton fluence to the total proton fluence 0 <= epsilon <= 0.2
    beam.current = 500; %| - _SCALAR_ -  Beam current density in uA/cm2
    beam.SpotDuration = 50; %ms Get the same number of proton fOr each spots. It is the fluence map that will change the number of protons
    MACHINE ='Pplus';
    beam=getBeamParam(MACHINE,beam,water);

    for E = 1:numel(E_ref)
      beam.R0 = R(E); %  _SCALAR_ -  Range (cm) of the pronton beam
      Dz = beamletBortfeld(Z, water , beam , false , false);
      intDose(E,:) = W(E) .* Dz;
    end

    DoseDepth = sum(intDose,1);
    Z = Z .* 10; %from cm to mm
  end
