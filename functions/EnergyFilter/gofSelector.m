%% gofSelector
% Compute the goodness of fit function between a target fluence map |FluenceRef|
% and the fluence map generated by a spike of a CEF:
%  The type of GOF to use is selected by the variable |gofType|
%
%% Syntax
% |[gof , Simu] = gofSelector(x , gofType , Plan , b , SpikeIdx , sigma0 , Meas_Zg , sigmas_far , FluenceRef, apertureMask , WaterThickeness , E_ref)|
%
%
%% Description
% |[gof , Simu] = gofSelector(x , gofType , Plan , b , SpikeIdx , sigma0 , Meas_Zg , sigmas_far , FluenceRef, apertureMask , WaterThickeness , E_ref)| Description
%
%
%% Input arguments
% |x| -_SCALAR VECTOR_- The optimised parameters |x = [A , dr1 , dr2, ... , drn]| where the relative width of the lowers step is dr1 and the relative width of the highest step is drn
%
% |gofType| -_STRING_- Defie the type og GOF to use. Options are 'SOBP' , 'fluence'
%
% |Plan| - _struct_ - MIROpt structure with updated information. See fluenceWithCEF.m for more information
%     * |Plan.Spike.intrpCTpxlSize| -_SCALAR_- Lateral resolution (mm) of the 3D printer. The steps are multiple of this value.
%
% |b| -_INTEGER_- Index of the beam in |Plan.Beams(b)| for which the fluence map is to be computed
%
% |SpikeIdx| -_INTEGER_- Index of the spike in |Plan.Beams(b).RidgeFilter(SpikeIdx)| that should be optimizes
%
% |Meas_Zg| -_SCALAR_- Z coordinate in IEC-Gantry (mm) of the plane in which the fluence is measured
%
% |showGraph| -_LOGICAL_- [Optional: defauly = false] If true, display the graphs ofthe fluence at different steps i nthe computations
%
% |sigmas_far| -_SCALAR VECTOR_- [OTPIONAL: if [], the sigma are computed by the function]. sigma (mm) of the lateral spread of the beam at |distance| of the scatterer
%
% |FluenceRef(x,y,E)| -_SCALAR MATRIX_-  Reference fluence at |distance| downstream from the CEF that the gof tries to reproduce. |Fluence(x,y,E)|  fluence at position (x,y) for proton of energy |Plan.Beams(b).Layers(E).Energy|
%
% |apertureMask| -_SCALAR MATRIX_- |apertureMask(x,y)=1| if the pixel is inside the aperture opening. The GOF is based only on the fluence inside the aperture opening. Empty if no aperture is used
%
% |WaterThickeness| -_SCALAR_- Thickness (mm) of the water tank placed at the position of hte measurement plane
%
% |SpikeType| -_STRING_- Type of spike to be designed. The centre of the spike corresponds to the BP with smaller range ('up') or the largest range ('down') or randomise pixel column ('random'), apply Gaussian filter to "smear"('smooth'), draw elliptical spike ('ellipse')
%
%% Output arguments
%
% |gof| - _SCALAR_ -  Goodness of fit. Sum of the square differences
%
% |Simu|  -_SCALAR MATRIX_-  Simulation result for the |x|. Definition depends on |gofType|
%
%
%% Contributors
% Authors : R. Labarbe (open.reggui@gmail.com)

function [gof , Simu] = gofSelector(x , gofType , Plan , b , SpikeIdx , Meas_Zg , sigmas_far , FluenceRef, apertureMask , WaterThickeness , E_ref , SpikeType)

    sFluenceRef = size(FluenceRef);

    if isempty(apertureMask)
      %If the aperture mask is empty, then use all fluence pixels in the computation of GOF
      apertureMask = ones(sFluenceRef);
    else
      %An aperture mask is provided. Repeat for eack energy layer
      apertureMask = repmat(apertureMask,1,sFluenceRef(3)); %repeat for every energy layer
      apertureMask = reshape(apertureMask,sFluenceRef);
    end

    pencil_x = [Plan.Beams(b).RidgeFilter(:).x_centre]; %Position of the centre of the spikes is also the centre of the PBS spots
    pencil_y = [Plan.Beams(b).RidgeFilter(:).y_centre];
    weight_table = [Plan.Beams(b).RidgeFilter(:).w]; % w(spt) is the weight of the spt-th PBS spot. The value is proportional to the number of proton at **maximum** energy

    [Plan.Beams(b).RidgeFilter , Xout , Xother] = packRgofFluence(x , Plan.Beams(b).RidgeFilter(SpikeIdx) , 0); %Update the width of the steps using the X variable
    %Plan contains the definition of one single spike after the call to packRgofFluence

    %Define the level of graphical display
    if Plan.showGraph
      showGraph = 2;
    else
      showGraph = 0;
    end

    %Compute the fluence map (for the single spike)
    [Fluence , mask , W0ext ] = getFluence(Plan , b , 1 , pencil_x , pencil_y , weight_table , [] , Meas_Zg , showGraph , sigmas_far, WaterThickeness , E_ref);

    switch gofType
        case 'SOBP'
            % The GOF is the comparison of the IDDs

            %Normalise the weight and compare the IDD
            W0ext = W0ext ./ sum(W0ext); %Normalise the weight
            W = squeeze(sum(Fluence .* mask,[1,2])); %Compute the weight of each energy layer
            W = W ./ sum(W); %Normalise the weight
            [Simu , Z] = W2dose(W  , E_ref ); %Integrated depth dose profile through CEF
            Ref    = W2dose(W0ext  , E_ref ); %Integrated depth dose profile of the IMPT plan

            if Plan.showGraph

              legendSTR = {};
              figure(151)
              hold off
              plot(Z , Ref , '-b')
              legendSTR{end+1}='Reference';
              hold on
              plot(Z , Simu , '-r')
              legendSTR{end+1}='Simulation';
              xlabel('Depth (mm)')
              ylabel('Relative dose')
              title('GOF : Integrated depth dose')
              grid on
              legend(legendSTR)

              figure(150)
              title(['Spike # ' num2str(SpikeIdx) '@ (' num2str(round(Plan.Beams(b).RidgeFilter(1).x_centre,1)) ' , ' num2str(round(Plan.Beams(b).RidgeFilter(1).y_centre,1)) ') mm'])


            end
            gof = sum((Simu - Ref).^2);

        case 'fluence'
            %The GOF is a comparison of the fluence maps
            Simu = Fluence ./ max(Fluence,[],'all'); %Normalise the fluence
            errorMap = sum((Simu - FluenceRef).^2 , 3) .* mask;

            if Plan.showGraph

              % figure(152)
              % legendSTR = {};
              % hold off
              % mask3 = repmat(mask,1,size(Simu,3));
              % mask3 = reshape(mask3,size(Simu,1),size(Simu,2),size(Simu,3));
              % plot(E_ref,squeeze(sum(Simu.*mask3, [1,2])),'-ob')
              % legendSTR{end+1}='Simulation';
              % hold on
              % plot(E_ref,squeeze(sum(FluenceRef.*mask3, [1,2])),'-+r')
              % legendSTR{end+1}='Reference';
              % xlabel('Energy (MeV)')
              % ylabel('Integral fluence')
              % title('Integral fluence vs energy layer')
              % legend(legendSTR)
              % grid on

              [xi,yi] = find(mask);

              % figure(153)
              % [~,imx] = max(Simu,[],'all','linear');
              % [~, ~ , iZ] = ind2sub(size(Simu),imx);
              % contour(squeeze(Simu(:,:,iZ)).* mask,'ShowText','on')
              % xlabel('X')
              % ylabel('Y')
              % title(['Simulated fluence at ' num2str(E_ref(iZ)) 'MeV'])
              % grid on
              % axis([min(xi),max(xi),min(yi),max(yi)])
              %
              % figure(154)
              % contour(squeeze(FluenceRef(:,:,iZ)).* mask,'ShowText','on')
              % xlabel('X')
              % ylabel('Y')
              % title(['Reference fluence at ' num2str(E_ref(iZ,0)) 'MeV'])
              % grid on
              % axis([min(xi),max(xi),min(yi),max(yi)])


              figure(151)
              NbCols = 3;
              NbRows = ceil((numel(E_ref)+2) ./ NbCols);
              for iZ = 1:numel(E_ref)
                  diffF = squeeze(FluenceRef(:,:,iZ)-Simu(:,:,iZ)).* mask;
                  if numel(unique(diffF)) > 1
                      subplot(NbRows,NbCols,iZ)
                      contour(diffF,'ShowText','on')
                      xlabel('X')
                      ylabel('Y')
                      title(['F_{ref} - F_{sim} at ' num2str(E_ref(iZ)) ' MeV'])
                      grid on
                      axis([min(xi),max(xi),min(yi),max(yi)])
                  end
              end

              subplot(NbRows,NbCols,iZ+1)
              legendSTR = {};
              hold off
              mask3 = repmat(mask,1,size(Simu,3));
              mask3 = reshape(mask3,size(Simu,1),size(Simu,2),size(Simu,3));
              plot(E_ref,squeeze(sum(Simu.*mask3, [1,2])),'-ob')
              legendSTR{end+1}='Simulation';
              hold on
              plot(E_ref,squeeze(sum(FluenceRef.*mask3, [1,2])),'-+r')
              legendSTR{end+1}='Reference';
              xlabel('Energy (MeV)')
              ylabel('Integral fluence')
              title('Integral fluence vs energy layer')
              %legend(legendSTR)
              grid on

              subplot(NbRows,NbCols,iZ+2)
              allHeights = (Plan.Beams(b).RidgeFilter(1).t_RF)';
              edges =[allHeights,allHeights(end)+1];
              N = histc(Xout,edges);
              bar(edges , N)
              hold on
              plot(allHeights,0,'*')
              xlabel('Tower height (mm)')
              ylabel('Number of towers')
              hold off
              grid on
              drawnow

              figure(150)
              title(['Spike # ' num2str(SpikeIdx) '@ (' num2str(round(Plan.Beams(b).RidgeFilter(1).x_centre,1)) ' , ' num2str(round(Plan.Beams(b).RidgeFilter(1).y_centre,1)) ') mm'])

            end

            gof = sum(errorMap , 'all');

    end



    switch Plan.Beams(b).RidgeFilter(1).SpikeType
      case 'fractal'
        % Do not change the gof
        % The step size of the optimzer was selected so that X is changed by units.
        % There is no need to further constriant the optimiser to stay with integers

     otherwise
        %If the vector x was outside of the constraints, then the value of GOF must be increased, in proportion to the deviation to the constraints
        %in order to bring the optimiser into the authorised range of x
        Normal = Xout;
        wNull = find(Normal==0);
        Normal(wNull)=1; %This element of x0 is null. No need to renormalise
        deviation = sum(abs((x - Xout) ./ Normal)) ./ numel(Xout); %average of all deviations outside the constrainted zone. Average makes the functrion smoother than max
        if deviation
          %If the x was outside of the constrained area, add a penalty to the gof value
          %Multiply the gof by the penalty factor in order to get a smooth function between inside and outside the constrainted area
          gof = gof .* exp(deviation);
        end

    end %switch


end

%=======================================================
%Convert the fluence into dose
%=======================================================
function [DoseDepth , Z] = W2dose(W  , E_ref )

    water = materialDescription('water');
    R = energy2range(E_ref, water.alpha,water.p); %Range (cm) of incoming particle

    %Convert fluence into dose using the Bortfeld depth dose profile
    Z = min(R):0.1:max(R);
    intDose = zeros(numel(E_ref), numel(Z));

    beam.epsilon = 0.2; % _SCALAR_ -  fraction of low energy proton fluence to the total proton fluence 0 <= epsilon <= 0.2
    beam.current = 500; %| - _SCALAR_ -  Beam current density in uA/cm2
    beam.SpotDuration = 50; %ms Get the same number of proton fOr each spots. It is the fluence map that will change the number of protons
    MACHINE ='Pplus';
    beam=getBeamParam(MACHINE,beam,water);

    for E = 1:numel(E_ref)
      beam.R0 = R(E); %  _SCALAR_ -  Range (cm) of the pronton beam
      Dz = beamletBortfeld(Z, water , beam , false , false);
      intDose(E,:) = W(E) .* Dz;
    end

    DoseDepth = sum(intDose,1);
    Z = Z .* 10; %from cm to mm

  end


%=====================================
% Compute the fluence for each energy layer
% Compute the mask representing the base of the spike
% Make sure that the energy layers are ordered in the smae order as |E_ref|
%=====================================
function [Fluence , mask , W0ext ] = getFluence (Plan , b , SpikeIdx , pencil_x , pencil_y ,weight_table  , SAD , Meas_Zg , showGraph , sigmas , Iso2RS , E_ref)

  %E_spike = Plan.Beams(b).RidgeFilter(SpikeIdx).Energy; %The energy corresponding to spot weights |w0_step|
  W0 = Plan.Beams(b).RidgeFilter(SpikeIdx).w0_step; % w_step(l) weight of the l-th energy layer to the spot |SpikeIdx|. Proportional to number of protons of **maximum** energy
  W0 = W0 ./ sum(W0); %Normalise the reference weights of the IMPT plan

  %Compute the fluence map (for the single spike)
  [FluenceSpk , X_far , Y_far , E_filter , ~ , ~ , maskLayer] = fluenceWithCEF(Plan , b , pencil_x , pencil_y  ,weight_table , SAD , Meas_Zg , showGraph , sigmas, 0, 'config_RS_CEM');

  %Make the computation only in the area of the spike
  mask = ~~sum(maskLayer,3);

  %compute the reference weights from the reference fluence map
  Fluence = zeros(numel(X_far),numel(Y_far), numel(E_ref));
  W0ext = zeros(numel(E_ref),1); %There are missing energy layers in the W0 reference

  for ind_E = 1:numel(E_filter)
      %If there are missing energy layers in this spike, sort energy layers to match reference
      idx = find(E_ref == E_filter(ind_E)); %Find the index of the energy layer corrsponding to cylinder j
      Fluence    (: , : , idx) = FluenceSpk(:,:,ind_E);
      W0ext(idx) = W0(ind_E); %Create a reference weight vector with all energy layers
  end

end
